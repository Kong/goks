From d93789e8af9b1d0d91d891d3473164b32db0db54 Mon Sep 17 00:00:00 2001
From: Harry Bagdi <harrybagdi@gmail.com>
Date: Wed, 1 Dec 2021 09:29:21 -0800
Subject: [PATCH 10/10] tools/utils.lua: misc patches for compat

- Use go.uuid instead of uuid
- Remove all code that uses the FFI interface
- Use go.rand for random bytes
- Use patched.url intead of socket.url
- Use Lua 5.1 based xpcall
- Use go.ipmatcher instead of resty.ipmatcher
- Use go.re2 instead of ngx.re
---
 lua-tree/share/lua/5.1/kong/tools/utils.lua | 225 +-------------------
 1 file changed, 11 insertions(+), 214 deletions(-)

diff --git a/lua-tree/share/lua/5.1/kong/tools/utils.lua b/lua-tree/share/lua/5.1/kong/tools/utils.lua
index 301d8d4..40e40ae 100644
--- a/lua-tree/share/lua/5.1/kong/tools/utils.lua
+++ b/lua-tree/share/lua/5.1/kong/tools/utils.lua
@@ -8,18 +8,11 @@
 -- @license [Apache 2.0](https://opensource.org/licenses/Apache-2.0)
 -- @module kong.tools.utils
 
-local ffi = require "ffi"
-local uuid = require "resty.jit-uuid"
+local uuid = require "go.uuid"
 local pl_stringx = require "pl.stringx"
 local pl_stringio = require "pl.stringio"
 local pl_utils = require "pl.utils"
-local pl_path = require "pl.path"
-local zlib = require "ffi-zlib"
 
-local C             = ffi.C
-local ffi_fill      = ffi.fill
-local ffi_new       = ffi.new
-local ffi_str       = ffi.string
 local type          = type
 local pairs         = pairs
 local ipairs        = ipairs
@@ -33,32 +26,10 @@ local fmt           = string.format
 local find          = string.find
 local gsub          = string.gsub
 local split         = pl_stringx.split
-local re_find       = ngx.re.find
-local re_match      = ngx.re.match
-local inflate_gzip  = zlib.inflateGzip
-local deflate_gzip  = zlib.deflateGzip
+local re_find       = require "go.re2".find
+local re_match      = require "go.re2".match
 local stringio_open = pl_stringio.open
 
-ffi.cdef[[
-typedef unsigned char u_char;
-
-int gethostname(char *name, size_t len);
-
-int RAND_bytes(u_char *buf, int num);
-
-unsigned long ERR_get_error(void);
-void ERR_load_crypto_strings(void);
-void ERR_free_strings(void);
-
-const char *ERR_reason_error_string(unsigned long e);
-
-int open(const char * filename, int flags, int mode);
-size_t read(int fd, void *buf, size_t count);
-int write(int fd, const void *ptr, int numbytes);
-int close(int fd);
-char *strerror(int errnum);
-]]
-
 local _M = {}
 
 --- splits a string.
@@ -112,111 +83,13 @@ do
   end
 end
 
-do
-  local trusted_certs_paths = {
-    "/etc/ssl/certs/ca-certificates.crt",                -- Debian/Ubuntu/Gentoo
-    "/etc/pki/tls/certs/ca-bundle.crt",                  -- Fedora/RHEL 6
-    "/etc/ssl/ca-bundle.pem",                            -- OpenSUSE
-    "/etc/pki/tls/cacert.pem",                           -- OpenELEC
-    "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem", -- CentOS/RHEL 7
-    "/etc/ssl/cert.pem",                                 -- OpenBSD, Alpine
-  }
-
-  function _M.get_system_trusted_certs_filepath()
-    for _, path in ipairs(trusted_certs_paths) do
-      if pl_path.exists(path) then
-        return path
-      end
-    end
-
-    return nil,
-           "Could not find trusted certs file in " ..
-           "any of the `system`-predefined locations. " ..
-           "Please install a certs file there or set " ..
-           "lua_ssl_trusted_certificate to an " ..
-           "specific filepath instead of `system`"
-  end
-end
-
-
-local get_rand_bytes
-
-do
-  local ngx_log = ngx.log
-  local WARN    = ngx.WARN
-
-  local system_constants = require "lua_system_constants"
-  local O_RDONLY = system_constants.O_RDONLY()
-  local bytes_buf_t = ffi.typeof "char[?]"
-
-  local function urandom_bytes(buf, size)
-    local fd = ffi.C.open("/dev/urandom", O_RDONLY, 0) -- mode is ignored
-    if fd < 0 then
-      ngx_log(WARN, "Error opening random fd: ",
-                    ffi_str(ffi.C.strerror(ffi.errno())))
-
-      return false
-    end
-
-    local res = ffi.C.read(fd, buf, size)
-    if res <= 0 then
-      ngx_log(WARN, "Error reading from urandom: ",
-                    ffi_str(ffi.C.strerror(ffi.errno())))
-
-      return false
-    end
-
-    if ffi.C.close(fd) ~= 0 then
-      ngx_log(WARN, "Error closing urandom: ",
-                    ffi_str(ffi.C.strerror(ffi.errno())))
-    end
-
-    return true
-  end
 
-  -- try to get n_bytes of CSPRNG data, first via /dev/urandom,
-  -- and then falling back to OpenSSL if necessary
-  get_rand_bytes = function(n_bytes, urandom)
-    local buf = ffi_new(bytes_buf_t, n_bytes)
-    ffi_fill(buf, n_bytes, 0x0)
-
-    -- only read from urandom if we were explicitly asked
-    if urandom then
-      local rc = urandom_bytes(buf, n_bytes)
-
-      -- if the read of urandom was successful, we returned true
-      -- and buf is filled with our bytes, so return it as a string
-      if rc then
-        return ffi_str(buf, n_bytes)
-      end
-    end
-
-    if C.RAND_bytes(buf, n_bytes) == 0 then
-      -- get error code
-      local err_code = C.ERR_get_error()
-      if err_code == 0 then
-        return nil, "could not get SSL error code from the queue"
-      end
-
-      -- get human-readable error string
-      C.ERR_load_crypto_strings()
-      local err = C.ERR_reason_error_string(err_code)
-      C.ERR_free_strings()
-
-      return nil, "could not get random bytes (" ..
-                  "reason:" .. ffi_str(err) .. ") "
-    end
-
-    return ffi_str(buf, n_bytes)
-  end
-
-  _M.get_rand_bytes = get_rand_bytes
-end
+local get_rand_bytes = require "go.rand".get_rand_bytes
 
 --- Generates a v4 uuid.
 -- @function uuid
 -- @return string with uuid
-_M.uuid = uuid.generate_v4
+_M.uuid = uuid.generate
 
 --- Generates a random unique string
 -- @return string  The random string (a chunk of base64ish-encoded random bytes)
@@ -249,7 +122,7 @@ function _M.is_valid_uuid(str)
   if type(str) ~= 'string' or #str ~= 36 then
     return false
   end
-  return re_find(str, uuid_regex, 'ioj') ~= nil
+  return re_find(str, uuid_regex) ~= nil
 end
 
 -- function below is more acurate, but invalidates previously accepted uuids and hence causes
@@ -260,7 +133,7 @@ end
 --end
 
 do
-  local url = require "socket.url"
+  local url = require "patched.url"
 
   --- URL escape and format key and value
   -- values should be already decoded or the `raw` option should be passed to prevent double-encoding
@@ -695,7 +568,7 @@ end
 -- @return success A boolean indicating wether the module was found.
 -- @return module The retrieved module, or the error in case of a failure
 function _M.load_module_if_exists(module_name)
-  local status, res = xpcall(require, debug.traceback, module_name)
+  local status, res = xpcall(function() return require(module_name) end, debug.traceback)
   if status then
     return true, res
   -- Here we match any character because if a module has a dash '-' in its name, we would need to escape it.
@@ -731,7 +604,7 @@ end
 
 
 do
-  local ipmatcher =  require "resty.ipmatcher"
+  local ipmatcher =  require "go.ipmatcher"
   local sub = string.sub
 
   local ipv4_prefixes = {}
@@ -1021,7 +894,7 @@ _M.validate_header_name = function(name)
     return nil, "no header name provided"
   end
 
-  if re_match(name, "^[a-zA-Z0-9-_]+$", "jo") then
+  if re_match(name, "^[a-zA-Z0-9-_]+$") then
     return name
   end
 
@@ -1039,7 +912,7 @@ _M.validate_cookie_name = function(name)
     return nil, "no cookie name provided"
   end
 
-  if re_match(name, "^[a-zA-Z0-9-_]+$", "jo") then
+  if re_match(name, "^[a-zA-Z0-9-_]+$") then
     return name
   end
 
@@ -1172,82 +1045,6 @@ function _M.bytes_to_str(bytes, unit, scale)
 end
 
 
-do
-  local NGX_ERROR = ngx.ERROR
-
-  if not pcall(ffi.typeof, "ngx_uint_t") then
-    ffi.cdef [[
-      typedef uintptr_t ngx_uint_t;
-    ]]
-  end
-
-  -- ngx_str_t defined by lua-resty-core
-  local s = ffi.new("ngx_str_t[1]")
-  s[0].data = "10"
-  s[0].len = 2
-
-  if not pcall(function() C.ngx_parse_time(s, 0) end) then
-    ffi.cdef [[
-      ngx_int_t ngx_parse_time(ngx_str_t *line, ngx_uint_t is_sec);
-    ]]
-  end
-
-  function _M.nginx_conf_time_to_seconds(str)
-    s[0].data = str
-    s[0].len = #str
-
-    local ret = C.ngx_parse_time(s, 1)
-    if ret == NGX_ERROR then
-      error("bad argument #1 'str'", 2)
-    end
-
-    return tonumber(ret, 10)
-  end
-end
-
-
-do
-  -- lua-ffi-zlib allocated buffer of length +1,
-  -- so use 64KB - 1 instead
-  local GZIP_CHUNK_SIZE = 65535
-
-  local function gzip_helper(op, input)
-    local f = stringio_open(input)
-    local output_table = {}
-    local output_table_n = 0
-
-    local res, err = op(function(size)
-      return f:read(size)
-    end,
-    function(res)
-      output_table_n = output_table_n + 1
-      output_table[output_table_n] = res
-    end, GZIP_CHUNK_SIZE)
-
-    if not res then
-      return nil, err
-    end
-
-    return concat(output_table)
-  end
-
-  --- Gzip compress the content of a string
-  -- @tparam string str the uncompressed string
-  -- @return gz (string) of the compressed content, or nil, err to if an error occurs
-  function _M.deflate_gzip(str)
-    return gzip_helper(deflate_gzip, str)
-  end
-
-
-  --- Gzip decompress the content of a string
-  -- @tparam string gz the Gzip compressed string
-  -- @return str (string) of the decompressed content, or nil, err to if an error occurs
-  function _M.inflate_gzip(gz)
-    return gzip_helper(inflate_gzip, gz)
-  end
-end
-
-
 local get_mime_type
 local get_error_template
 do
-- 
2.25.1

